# Factory Events – Backend System

## Project Overview

This service ingests high-volume machine event data, validates and deduplicates events, applies deterministic conditional updates, and exposes APIs to query operational statistics over defined time windows.

The design prioritizes correctness, thread-safety, and explainability while meeting the required performance constraints.

### High-level Goals

- Correctly ingest and store machine events
- Deterministically handle duplicates and updates
- Ensure thread safety under concurrent ingestion
- Provide accurate, time-windowed statistics APIs
- Be fully testable and easy to reason about

---
## Tech Stack

- **Language:** Java 21
- **Framework:** Spring Boot (Spring MVC)
- **Database:** PostgreSQL
- **Data Access:** JDBC (batch writes), Spring Data JPA (reads)
- **Testing:** JUnit 5, MockMvc, Testcontainers
- **Build Tool:** Maven
- **Infrastructure:** Docker, Docker Compose

---
## Architecture

The application follows a layered Spring Boot architecture:

Controller → Service → DAO / Repository → Database

### Components

**Controllers**
- EventController: batch ingestion
- StatsController: statistics queries

**Services**
- EventService: validation, deduplication, update logic
- StatsService: aggregation and computation logic

**Write Path**
- EventBatchDao: JDBC-based batch insert and conditional update

**Read Path**
- EventRepository: read-side queries using Spring Data JPA + native SQL

**Database**
- PostgreSQL (used in tests via Testcontainers)

**Infrastructure**
- Clock abstraction for deterministic time
- Global exception handler for clean API errors

---

## Data Model

### Table - event

| Column        | Type        | Description                         |
|--------------|-------------|-------------------------------------|
| id            | BIGSERIAL   | Primary key                         |
| event_id      | VARCHAR     | External event identifier (unique)  |
| factory_id    | VARCHAR     | Factory identifier                  |
| line_id       | VARCHAR     | Production line identifier          |
| machine_id    | VARCHAR     | Machine identifier                  |
| event_time    | TIMESTAMPTZ | When the event occurred             |
| received_time | TIMESTAMPTZ | When the backend accepted the event |
| duration_ms   | BIGINT      | Duration of the event               |
| defect_count  | INT         | Number of defects                   |

### Indexes

- Unique index on `event_id`
- `(machine_id, event_time)` for machine stats
- `(factory_id, line_id, event_time)` for aggregation

### Design Rationale

- `event_time` is used for all analytical queries
- `received_time` is used only for conflict resolution
- Database constraints are preferred over application-level locking

---

## Event Ingestion Logic

### Ingestion Flow

1. Client sends a batch of events
2. Events are validated
3. Valid events are batch-inserted
4. Conflicts are conditionally updated
5. Result counters are aggregated and returned

### Validation Rules

- `durationMs` must satisfy `0 ≤ durationMs ≤ 6 hours`
- `eventTime` must not be more than 15 minutes in the future
- Bean validation must pass
- Invalid events are rejected with reasons

### Deduplication vs Update

- Same `eventId` + identical payload → deduped
- Same `eventId` + different payload → update only if newer

### Payload Comparison

Payloads differ if any of these fields differ:
- factoryId
- lineId
- machineId
- eventTime
- durationMs
- defectCount

Comparison is enforced in SQL using `IS DISTINCT FROM`.

### receivedTime Tie-Breaker

- Always generated by the server
- Client values ignored
- Newer receivedTime always wins

---

## Thread Safety Guarantees

The system is thread-safe without explicit locks.

### Mechanisms

- Unique constraint on `event_id`
- Atomic SQL operations
- Conditional updates using received_time
- Single transaction per batch
- Stateless services

### Result

- No duplicate rows
- No stale overwrites
- Safe under concurrent ingestion

---

## Performance Strategy

- JDBC batch inserts instead of ORM writes
- Single transaction per batch
- Database-level conflict resolution
- Separation of read/write paths
- No per-event locking


---

## Stats Computation Logic

### Machine Stats

For `(machineId, start, end)`:

- Time window: start inclusive, end exclusive
- eventsCount: count of valid events
- defectsCount: sum of defectCount excluding -1
- avgDefectRate = defectsCount / windowHours
- status:
   - Healthy if avgDefectRate < 2.0
   - Warning otherwise

### Top Defect Lines

For `(factoryId, from, to)`:

- Grouped by lineId
- defectCount = -1 excluded
- defectsPercent = (totalDefects * 100) / eventCount
- Sorted by totalDefects, then eventCount
- Limited to max 100 results

---

## Endpoints Summary 

### 1. POST /events/batch

**Input**
- JSON array of events (thousands per request)

**Output**
- Counts of accepted, deduped, updated, rejected events
- List of rejection reasons

---

### 2. GET /stats

**Input**
- machineId
- start timestamp
- end timestamp

**Output**
- eventsCount
- defectsCount
- avgDefectRate
- status

---

### 3. GET /stats/top-defect-lines

**Input**
- factoryId
- from timestamp
- to timestamp
- limit

**Output**
- List of lineId, totalDefects, eventCount, defectsPercent

---

## Tests

### Strategy

- Full integration tests
- Real PostgreSQL via Testcontainers
- MockMvc for HTTP calls
- MutableClock for deterministic time
- No mocks of business logic

### Mandatory Coverage

1. Duplicate eventId deduped
2. Newer update applied
3. Older update ignored
4. Invalid duration rejected
5. Future eventTime rejected
6. defectCount = -1 ignored
7. start/end boundary correctness
8. Concurrent ingestion thread safety

---

## Setup & Run Instructions

### Prerequisites

- Java 21
- Maven
- Docker

### Database Startup

PostgreSQL was started locally using Docker Compose:
```bash
docker-compose up -d
```
### Application Startup
The application was started locally using Spring Boot:
```bash
mvn spring-boot:run
```
OR (Alternative command on Windows)
```bash
.\mvnw -Dmaven.clean.failOnError=false clean spring-boot:run
```

### Run Tests
```bash
mvn test
```
OR (Alternative command on Windows)

```bash
.\mvnw test
```

---

## Future Improvements

- Pagination - add pagination to stats APIs using Spring/JPA to handle large result sets.
- Structured Errors codes - introduce consistent API error codes using a simple enum.
- Logging - improve logging for event ingestion and rejected events.

